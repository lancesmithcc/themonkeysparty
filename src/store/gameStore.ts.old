import { create } from 'zustand';
import * as THREE from 'three';

// Constants for platform bounds checking
const PLATFORM_RADIUS = 4;
const MOVEMENT_SPEED = 0.005; // Reduced from 0.01
const MAX_SPEED = 0.01; // Reduced from 0.02
const ACCELERATION = 0.0005; // Reduced from 0.001
const DECELERATION = 0.002;
const COLLISION_DISTANCE = 0.4;
const COLLISION_DURATION = 3000; // Milliseconds collision effect lasts
const KNOCKBACK_FORCE = 0.15; // Force applied when characters collide
const MUSHROOM_COLLECT_DISTANCE = 0.5; // Distance required to collect a mushroom
const MAX_MUSHROOMS = 8; // Maximum number of mushrooms on the platform at once
const MUSHROOM_POINTS = 10; // Increased base points for collecting a mushroom (from 5 to 10)
const MUSHROOM_BONUS_MIN = 1; // Minimum bonus points
const MUSHROOM_BONUS_MAX = 5; // Maximum bonus points
const MUSHROOM_SPAWN_DELAY = 2000; // Time in ms between mushroom spawns
const MIN_MUSHROOMS = 5; // Minimum number of mushrooms that should be on the platform

// Constants for eyeball configuration
const EYEBALL_COLLECT_DISTANCE = 0.7; // Larger collection distance than mushrooms
const EYEBALL_POINTS = 50; // Significant points for collecting a rare eyeball
const EYEBALL_BONUS_MIN = 10; // Minimum bonus points
const EYEBALL_BONUS_MAX = 30; // Maximum bonus points
const MUSHROOMS_PER_EYEBALL = 33; // Spawn an eyeball after this many mushrooms collected
const MAX_EYEBALLS = 1; // Only one eyeball at a time
const PURPLE_STATE_DURATION = 13000; // Duration of purple state in milliseconds
const POINTS_STEAL_AMOUNT = 15; // Amount of points stolen when in purple state
const POINTS_STEAL_COOLDOWN = 2000; // Cooldown between point stealing in milliseconds
const EYEBALL_FORCE_SPAWN_DELAY = 30000; // Spawn an eyeball after this many ms if none has spawned
const EYEBALL_RESPAWN_DELAY = 5000; // Delay before attempting to respawn an eyeball

// TV position and collision box size
const TV_POSITION = [0, 1.5, -4.5];
const TV_SIZE = { width: 2.5, height: 3, depth: 1.5 };

// Add new constants for purple collision effect
const PURPLE_COLLISION_POINTS = 100; // Points lost when hit by a purple character
const PURPLE_KNOCKBACK_FORCE = 0.6; // Stronger knockback for purple collisions
const PURPLE_COLLISION_COOLDOWN = 1000; // Cooldown between collisions in ms

// Add new constants for hit animation
const HIT_ANIMATION_DURATION = 600; // Duration of hit animation in ms

// Add new constants for melting animation
const MELTING_ANIMATION_DURATION = 3000; // Duration of melting animation in ms

// Constants for melting characters
const MELTING_DURATION = 2; // Duration in seconds for melting animation
const PUDDLE_SCALE = 0.5; // Scale for the melted puddle

// Helper function to check if a position is within hexagon bounds
function isWithinHexagon(x: number, z: number, radius: number): boolean {
  // Hexagon boundary check (based on regular hexagon math)
  const absoluteX = Math.abs(x);
  const absoluteZ = Math.abs(z);
  
  // Check against hexagon boundaries
  if (absoluteX > radius * Math.sqrt(3) / 2) return false;
  if (absoluteZ > radius) return false;
  if (absoluteX * 0.5 + absoluteZ * Math.sqrt(3) / 2 > radius * Math.sqrt(3) / 2) return false;
  
  return true;
}

// Helper function to check if a position collides with the TV
function isCollidingWithTV(x: number, z: number): boolean {
  // Simple box collision check with the TV
  const halfWidth = TV_SIZE.width / 2;
  const halfDepth = TV_SIZE.depth / 2;
  
  return (
    x > TV_POSITION[0] - halfWidth && 
    x < TV_POSITION[0] + halfWidth && 
    z > TV_POSITION[2] - halfDepth && 
    z < TV_POSITION[2] + halfDepth
  );
}

// Fibonacci sequence helper for NPC movement
function getFibonacciNumber(n: number): number {
  if (n <= 0) return 0;
  if (n === 1) return 1;
  
  let a = 0;
  let b = 1;
  let result = 0;
  
  for (let i = 2; i <= n; i++) {
    result = a + b;
    a = b;
    b = result;
  }
  
  return result;
}

// Define the interface for second NPC target settings
interface SecondNpcTargetSettings {
  timer: number;
  moveDirection: THREE.Vector3;
  fibStep: number;
  fibDirection: number;
}

// Define the mushroom interface
interface Mushroom {
  id: number;
  position: [number, number, number];
  scale: number;
  collected: boolean;
  collectedBy: string | null;
  animationProgress: number;
}

// Define the eyeball interface
interface Eyeball {
  id: number;
  position: [number, number, number];
  scale: number;
  collected: boolean;
  collectedBy: string | null;
  animationProgress: number;
}

// Define the game state interface
export interface GameState {
  // Player state
  playerPosition: [number, number, number];
  playerRotation: [number, number, number];
  playerSpeed: [number, number, number];
  isMoving: boolean;
  isStrafing: boolean;
  currentSpeed: number;
  movementDirection: [number, number];
  moveDirection: THREE.Vector3;
  isPlayerMoving: boolean;
  playerScore: number;
  isPlayerPurple: boolean; // Purple state for player
  playerPurpleEndTime: number; // When the purple state ends
  playerLastStealTime: number; // Last time player stole points
  
  // Platform state
  platformColor: [number, number, number];
  
  // NPC state
  npcPosition: [number, number, number];
  npcRotation: [number, number, number];
  npcTarget: [number, number, number];
  npcWanderTimer: number;
  shouldNpcMove: boolean;
  npcMoveDirection: THREE.Vector3;
  npcFibStep: number;
  npcFibDirection: number;
  npcScore: number;
  isNpcPurple: boolean; // Purple state for first NPC
  npcPurpleEndTime: number; // When the purple state ends
  npcLastStealTime: number; // Last time NPC stole points
  
  // Collision state
  isColliding: boolean;
  isCollidingWithTV: boolean;
  collisionPosition: [number, number, number];
  collisionTime: number;
  
  // Mobile state
  isMobile: boolean;
  setIsMobile: (isMobile: boolean) => void;
  
  // Methods for player movement
  handleKeyDown: (key: string) => void;
  handleKeyUp: (key: string) => void;
  setMoveDirection: (direction: THREE.Vector3) => void;
  updatePosition: () => void;
  
  // Methods for NPC movement
  updateNpcPosition: () => void;
  setNewNpcTarget: () => void;
  
  // Collision detection
  checkCollision: () => void;
  
  // Second NPC properties
  secondNpcPosition: [number, number, number];
  secondNpcRotation: [number, number, number];
  secondNpcMoveDirection: THREE.Vector3;
  secondNpcFibStep: number;
  secondNpcFibDirection: number;
  secondNpcWanderTimer: number;
  shouldSecondNpcMove: boolean;
  secondNpcScore: number;
  secondNpcLastPosition: [number, number, number]; // To track if NPC is stuck
  secondNpcStuckCounter: number; // Counter for how long NPC has been stuck
  isSecondNpcPurple: boolean; // Purple state for second NPC
  secondNpcPurpleEndTime: number; // When the purple state ends
  secondNpcLastStealTime: number; // Last time second NPC stole points
  
  // Methods for second NPC movement
  updateSecondNpcPosition: () => void;
  setNewSecondNpcTarget: (state: GameState, settings: SecondNpcTargetSettings) => Partial<GameState>;
  
  // Update NPC scores
  updateNpcScore: () => void;
  updateSecondNpcScore: () => void;
  
  // Mushroom state
  mushrooms: Mushroom[];
  lastMushroomId: number;
  lastMushroomSpawnTime: number;
  
  // Mushroom actions
  spawnMushroom: () => void;
  updateMushrooms: (deltaTime: number) => void;
  collectMushroom: (id: number, collector: string) => void;
  
  // TV positioning for collision detection
  tvPosition: [number, number, number];
  tvSize: number;
  
  // Eyeball state
  eyeballs: Eyeball[];
  lastEyeballId: number;
  lastEyeballSpawnTime: number;
  mushroomsCollectedSinceLastEyeball: number; // Counter for tracking mushrooms collected
  
  // Eyeball methods
  trySpawnEyeball: () => void;
  updateEyeballs: (deltaTime: number) => void;
  collectEyeball: (id: number, collector: string) => void;
  
  // New methods for purple state
  updatePurpleStates: () => void;
  checkPointStealing: () => void;
  
  // Add cooldown timestamps for purple collisions
  playerLastCollisionTime: number;
  npcLastCollisionTime: number;
  secondNpcLastCollisionTime: number;
  
  // Add new method for purple collision detection
  checkPurpleCollisions: () => void;
  
  // Add hit states for visual effects
  isPlayerHit: boolean;
  playerHitTime: number;
  isNpcHit: boolean;
  npcHitTime: number;
  isSecondNpcHit: boolean;
  secondNpcHitTime: number;
  
  // Add method to update hit animation states
  updateHitStates: () => void;
  
  // Add melted states for characters
  playerMelted: boolean;
  npcMelted: boolean;
  secondNpcMelted: boolean;
  playerMeltStartTime: number;
  npcMeltStartTime: number;
  secondNpcMeltStartTime: number;
  
  // Melting and game over properties
  playerMeltProgress: number;
  npcMeltProgress: number;
  secondNpcMeltProgress: number;
  gameOver: boolean;
  winner: string | null;
  
  // Melting and game over methods
  checkMeltConditions: () => void;
  meltCharacter: (character: string) => void;
  updateMeltProgress: () => void;
  resetGame: () => void;
  
  // Hit state methods
  setPlayerHit: () => void;
  setNpcHit: () => void;
  setSecondNpcHit: () => void;
}

export const useGameStore = create<GameState>((set, get) => ({
  // Player state
  playerPosition: [0, 0, 0],
  playerRotation: [0, 0, 0],
  playerSpeed: [0, 0, 0],
  isMoving: false,
  isStrafing: false,
  currentSpeed: 0,
  movementDirection: [0, 0],
  moveDirection: new THREE.Vector3(0, 0, 0),
  isPlayerMoving: false,
  playerScore: 50,
  
  // Platform color - randomly changes based on collisions
  platformColor: [1, 1, 1],
  
  // NPC state
  npcPosition: [3, 0, 3],
  npcRotation: [0, 0, 0],
  npcTarget: [0, 0, 0],
  npcWanderTimer: 0,
  shouldNpcMove: true,
  npcMoveDirection: new THREE.Vector3(Math.random(), 0, Math.random()).normalize(),
  npcFibStep: 5,
  npcFibDirection: 1,
  npcScore: 50,
  
  // NPC is purple state
  isNpcPurple: false,
  npcPurpleEndTime: 0,
  npcLastStealTime: 0,
  
  // Second NPC properties
  secondNpcPosition: [-3, 0, -3],
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(-Math.random(), 0, -Math.random()).normalize(),
  secondNpcFibStep: 3,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3],
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
        state.spawnMushroom();
        console.log(`Spawning initial mushroom ${i+1}/${MIN_INITIAL_MUSHROOMS}`);
      }, i * 100);
    }
    
    // Force set mushrooms collected to allow eyeball spawn
    setTimeout(() => {
      set({ mushroomsCollectedSinceLastEyeball: MUSHROOMS_PER_EYEBALL });
      console.log("Setting mushrooms collected to force eyeball spawn");
      
      // Stagger the eyeball spawns
      for (let i = 0; i < MIN_INITIAL_EYEBALLS; i++) {
        setTimeout(() => {
          console.log(`Trying to spawn eyeball ${i+1}/${MIN_INITIAL_EYEBALLS}`);
          state.trySpawnEyeball();
        }, i * 200);
      }
    }, MIN_INITIAL_MUSHROOMS * 100 + 200);
  },
  
  // Purple state properties
  playerIsPurple: false,
  npcIsPurple: false,
  secondNpcIsPurple: false,
  
  // Hit state methods
  setPlayerHit: () => set({ isPlayerHit: true, playerHitTime: Date.now() }),
  setNpcHit: () => set({ isNpcHit: true, npcHitTime: Date.now() }),
  setSecondNpcHit: () => set({ isSecondNpcHit: true, secondNpcHitTime: Date.now() })
}));

// Helper function for setting second NPC target
function setNewSecondNpcTarget(state: GameState, { timer, moveDirection, fibStep, fibDirection }: SecondNpcTargetSettings): Partial<GameState> {
  return state.setNewSecondNpcTarget(state, { timer, moveDirection, fibStep, fibDirection });
}

// Add a new error handling utility
function safeExecute(fn: () => void, errorMsg: string) {
  try {
    fn();
  } catch (error) {
    console.error(`${errorMsg}:`, error);
  }
}
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
  // Check for collision between player and NPC - now removed and replaced with TV collision
  checkCollision: () => {
    // No longer needed - removed character collision detection
  },
  
  // Second NPC initialization
  secondNpcPosition: [-3, 0, -3], // Match resetGame position
  secondNpcRotation: [0, 0, 0],
  secondNpcMoveDirection: new THREE.Vector3(),
  secondNpcFibStep: 1,
  secondNpcFibDirection: 1,
  secondNpcWanderTimer: 0,
  shouldSecondNpcMove: true,
  secondNpcScore: 50,
  secondNpcLastPosition: [-3, 0, -3], // Initialize with same position
  secondNpcStuckCounter: 0,
  
  // Second NPC is purple state
  isSecondNpcPurple: false,
  secondNpcPurpleEndTime: 0,
  secondNpcLastStealTime: 0,
  
  // Player is purple state
  isPlayerPurple: false,
  playerPurpleEndTime: 0,
  playerLastStealTime: 0,
  
  // Melting states and progress
  playerMelted: false,
  npcMelted: false,
  secondNpcMelted: false,
  playerMeltProgress: 0,
  npcMeltProgress: 0,
  secondNpcMeltProgress: 0,
  playerMeltStartTime: 0,
  npcMeltStartTime: 0,
  secondNpcMeltStartTime: 0,
  
  // Collision state
  isColliding: false,
  isCollidingWithTV: false,
  collisionPosition: [0, 0, 0],
  collisionTime: 0,
  
  // Mobile state
  isMobile: false,
  setIsMobile: (isMobile) => set({ isMobile }),
  
  // Set the movement direction based on key input
  handleKeyDown: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Toggle strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: true });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
      case 'KeyW':
        newDirection.z = -1;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
      case 'KeyS':
        newDirection.z = 1;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        newDirection.x = -1;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        newDirection.x = 1;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Clear the movement direction when key is released
  handleKeyUp: (key: string) => {
    const { moveDirection, isStrafing } = get();
    const newDirection = new THREE.Vector3(moveDirection.x, moveDirection.y, moveDirection.z);
    
    // Reset strafing mode
    if (key === 'Shift' || key === 'ShiftLeft' || key === 'ShiftRight') {
      set({ isStrafing: false });
      return;
    }
    
    switch (key) {
      case 'w':
      case 'W':
      case 'ArrowUp':
        if (moveDirection.z === -1) newDirection.z = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if (moveDirection.z === 1) newDirection.z = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
      case 'KeyA':
        if (moveDirection.x === -1) newDirection.x = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
      case 'KeyD':
        if (moveDirection.x === 1) newDirection.x = 0;
        break;
    }
    
    set({ 
      moveDirection: newDirection,
      isPlayerMoving: newDirection.length() > 0
    });
  },
  
  // Set movement direction directly (for mobile controls)
  setMoveDirection: (direction) => {
    set({ 
      moveDirection: direction,
      isPlayerMoving: direction.length() > 0
    });
  },
  
  // Update the player's position based on the movement direction with smooth acceleration/deceleration
  updatePosition: () => {
    const { playerPosition, moveDirection, currentSpeed, isPlayerMoving } = get();
    
    // Calculate new speed with acceleration or deceleration
    let newSpeed = currentSpeed;
    
    if (isPlayerMoving) {
      // Accelerate when moving
      newSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
      // Decelerate when not pressing any keys
      newSpeed = Math.max(currentSpeed - DECELERATION, 0);
    }
    
    // Only update position if we have some speed
    if (newSpeed > 0) {
      // Normalize for diagonal movement
      const normalizedDirection = moveDirection.clone().normalize();
      
      // Calculate new position
      const newX = playerPosition[0] + normalizedDirection.x * newSpeed;
      const newZ = playerPosition[2] + normalizedDirection.z * newSpeed;
      
      // Check for TV collision
      if (isCollidingWithTV(newX, newZ)) {
        // Hit TV boundary, reduce speed and prevent movement
        set({ 
          currentSpeed: newSpeed * 0.2,
          isCollidingWithTV: true
        });
        return;
      } else {
        set({ isCollidingWithTV: false });
      }
      
      // Check if the new position is within bounds
      if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
        set({ 
          playerPosition: [newX, playerPosition[1], newZ],
          currentSpeed: newSpeed
        });
        
        // Check for mushroom collection
        const { mushrooms } = get();
        mushrooms.forEach(mushroom => {
          if (mushroom.collected) return;
          
          const dx = mushroom.position[0] - newX;
          const dz = mushroom.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < MUSHROOM_COLLECT_DISTANCE) {
            get().collectMushroom(mushroom.id, 'player');
          }
        });
        
        // Check for eyeball collection
        const { eyeballs } = get();
        eyeballs.forEach(eyeball => {
          if (eyeball.collected) return;
          
          const dx = eyeball.position[0] - newX;
          const dz = eyeball.position[2] - newZ;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance < EYEBALL_COLLECT_DISTANCE) {
            get().collectEyeball(eyeball.id, 'player');
          }
        });
        
        // Check for point stealing when player is in purple state
        get().checkPointStealing();
      } else {
        // Hit boundary, reduce speed more quickly
        set({ currentSpeed: newSpeed * 0.5 });
      }
    } else {
      // If speed is zero, ensure we store that
      set({ currentSpeed: 0 });
    }
  },
  
  // Update NPC position based on calculated path and allow for stops
  updateNpcPosition: () => {
    const state = get();
    
    // Skip if movement disabled
    if (!state.shouldNpcMove) return;
    
    const now = Date.now();
    let { npcWanderTimer, npcPosition, npcRotation, npcMoveDirection, npcFibStep, npcFibDirection } = state;
    
    // Get next Fibonacci value (for variable timing)
    const fibValue = getFibonacciNumber(state.npcFibStep);
    
    // Check if it's time to stop/change direction
    if (now > npcWanderTimer) {
      // 30% chance to stop for a while
      if (Math.random() < 0.3) {
        // Longer pause when stopping (using Fibonacci for varied timing)
        const pauseDuration = fibValue * 100 + 1000;
        console.log(`NPC pausing for ${pauseDuration}ms`);
        
        set({
          npcWanderTimer: now + pauseDuration,
          shouldNpcMove: false
        });
        
        // Set a timeout to resume movement
        setTimeout(() => {
          set({ shouldNpcMove: true });
        }, pauseDuration);
        
        return;
      }
      
      // Otherwise, change direction more frequently
      const newDirection = new THREE.Vector3();
      
      // 85% chance of slight direction change, 15% chance of major change
      if (Math.random() < 0.85) {
        // Get current direction and add some randomness
        newDirection.copy(npcMoveDirection);
        
        // Add jitter - random angle between -45 and 45 degrees
        const angle = (Math.random() - 0.5) * Math.PI / 2;
        newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      } else {
        // Completely new random direction
        newDirection.set(
          Math.random() * 2 - 1,
          0,
          Math.random() * 2 - 1
        ).normalize();
      }
      
      // Update Fibonacci pattern step
      const newFibStep = state.npcFibStep + state.npcFibDirection;
      
      // Reverse direction if we reach limits
      let newFibDirection = state.npcFibDirection;
      if (newFibStep > 10 || newFibStep < 1) {
        newFibDirection = -newFibDirection;
      }
      
      // Random timer between 300ms and 1000ms + Fibonacci scaling
      const dirChangeDelay = Math.random() * 700 + 300 + fibValue * 8;
      
      set({
        npcMoveDirection: newDirection,
        npcWanderTimer: now + dirChangeDelay,
        npcFibStep: newFibStep,
        npcFibDirection: newFibDirection
      });
    }
    
    // Only move if we should move
    if (state.shouldNpcMove) {
      // Vary the speed slightly for more natural movement
      const speed = 0.02 + (Math.random() * 0.01);
      
      // Calculate new position
      const newPosition: [number, number, number] = [...state.npcPosition];
      newPosition[0] += state.npcMoveDirection.x * speed;
      newPosition[2] += state.npcMoveDirection.z * speed;
      
      // Check for TV collision
      if (isCollidingWithTV(newPosition[0], newPosition[2])) {
        // Bounce off the TV with randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(
          -state.npcMoveDirection.x,
          0,
          -state.npcMoveDirection.z
        ).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 4;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay away from TV
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Ensure NPC stays within platform bounds
      const distance = Math.sqrt(newPosition[0] * newPosition[0] + newPosition[2] * newPosition[2]);
      if (distance > PLATFORM_RADIUS * 0.95) {
        // Bounce off the edge with a bit of randomness
        state.npcMoveDirection.reflect(new THREE.Vector3(newPosition[0], 0, newPosition[2]).normalize());
        
        // Add slight random deviation after bounce
        const bounceAngle = (Math.random() - 0.5) * Math.PI / 6;
        state.npcMoveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), bounceAngle);
        
        // Recalculate position to stay in bounds
        newPosition[0] = state.npcPosition[0] + state.npcMoveDirection.x * speed;
        newPosition[2] = state.npcPosition[2] + state.npcMoveDirection.z * speed;
      }
      
      // Calculate rotation to face movement direction
      const targetRotation = Math.atan2(state.npcMoveDirection.x, state.npcMoveDirection.z);
      
      set({
        npcPosition: newPosition,
        npcRotation: [0, targetRotation, 0] as [number, number, number],
        isPlayerMoving: true
      });
      
      // Check for mushroom collection
      const { mushrooms } = get();
      mushrooms.forEach(mushroom => {
        if (mushroom.collected) return;
        
        const dx = mushroom.position[0] - newPosition[0];
        const dz = mushroom.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < MUSHROOM_COLLECT_DISTANCE) {
          get().collectMushroom(mushroom.id, 'npc');
        }
      });
      
      // Check for eyeball collection
      const { eyeballs } = get();
      eyeballs.forEach(eyeball => {
        if (eyeball.collected) return;
        
        const dx = eyeball.position[0] - newPosition[0];
        const dz = eyeball.position[2] - newPosition[2];
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < EYEBALL_COLLECT_DISTANCE) {
          get().collectEyeball(eyeball.id, 'npc');
        }
      });
      
      // Check for point stealing when NPC is in purple state
      get().checkPointStealing();
      
      // Update the score when moving
      get().updateNpcScore();
    } else {
      // If not moving, make sure isPlayerMoving is false for correct animation
      set({ isPlayerMoving: false });
    }
  },
  
  // Set a new target for the NPC based on Fibonacci pattern
  setNewNpcTarget: () => {
    const { npcFibStep, npcFibDirection, npcPosition } = get();
    
    // Use Fibonacci number to determine distance but scale up for longer paths
    const fibNumber = getFibonacciNumber(npcFibStep);
    const normalizedFib = fibNumber / 10; // Scale down to reasonable values
    
    // Increase distance to encourage exploration of the entire platform
    // Use 85-100% of the platform radius for wider coverage
    const distance = PLATFORM_RADIUS * (0.85 + Math.random() * 0.15);
    
    // Add more randomness to the direction for unpredictable movement
    const randomOffset = (Math.random() - 0.5) * Math.PI / 2; // ±45 degrees randomness (increased)
    const direction = npcFibDirection + randomOffset;
    
    // Calculate new target position using the direction
    const newX = Math.cos(direction) * distance;
    const newZ = Math.sin(direction) * distance;
    
    // 15% chance to aim for a completely random point on the platform
    if (Math.random() < 0.15) {
      // Generate a random angle
      const randomAngle = Math.random() * Math.PI * 2; 
      // Random distance from 50-100% of platform radius
      const randomDistance = PLATFORM_RADIUS * (0.5 + Math.random() * 0.5);
      
      const randomX = Math.cos(randomAngle) * randomDistance;
      const randomZ = Math.sin(randomAngle) * randomDistance;
      
      // Ensure target is within platform bounds
      if (isWithinHexagon(randomX, randomZ, PLATFORM_RADIUS)) {
        set({ npcTarget: [randomX, 0, randomZ] });
        return;
      }
    }
    
    // Ensure target is within platform bounds
    if (isWithinHexagon(newX, newZ, PLATFORM_RADIUS)) {
      set({ npcTarget: [newX, 0, newZ] });
    } else {
      // If outside bounds, pick a point toward an edge
      // Find the closest point on the hexagon edge
      const angle = Math.atan2(newZ, newX);
      const safeDistance = PLATFORM_RADIUS * 0.95; // Very close to edge
      set({ 
        npcTarget: [
          Math.cos(angle) * safeDistance,
          0,
          Math.sin(angle) * safeDistance
        ]
      });
    }
  },
  
        state.spawnMushroom();
        console.log(`Spawning initial mushroom ${i+1}/${MIN_INITIAL_MUSHROOMS}`);
      }, i * 100);
    }
    
    // Force set mushrooms collected to allow eyeball spawn
    setTimeout(() => {
      set({ mushroomsCollectedSinceLastEyeball: MUSHROOMS_PER_EYEBALL });
      console.log("Setting mushrooms collected to force eyeball spawn");
      
      // Stagger the eyeball spawns
      for (let i = 0; i < MIN_INITIAL_EYEBALLS; i++) {
        setTimeout(() => {
          console.log(`Trying to spawn eyeball ${i+1}/${MIN_INITIAL_EYEBALLS}`);
          state.trySpawnEyeball();
        }, i * 200);
      }
    }, MIN_INITIAL_MUSHROOMS * 100 + 200);
  },
  
  // Purple state properties
  playerIsPurple: false,
  npcIsPurple: false,
  secondNpcIsPurple: false,
  
  // Hit state methods
  setPlayerHit: () => set({ isPlayerHit: true, playerHitTime: Date.now() }),
  setNpcHit: () => set({ isNpcHit: true, npcHitTime: Date.now() }),
  setSecondNpcHit: () => set({ isSecondNpcHit: true, secondNpcHitTime: Date.now() })
}));

// Helper function for setting second NPC target
function setNewSecondNpcTarget(state: GameState, { timer, moveDirection, fibStep, fibDirection }: SecondNpcTargetSettings): Partial<GameState> {
  return state.setNewSecondNpcTarget(state, { timer, moveDirection, fibStep, fibDirection });
}

// Add a new error handling utility
function safeExecute(fn: () => void, errorMsg: string) {
  try {
    fn();
  } catch (error) {
    console.error(`${errorMsg}:`, error);
  }
}